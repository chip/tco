#!/usr/bin/env ruby

# tco - terminal colouring application and library
# Copyright (C) 2013 Radek Pazdera
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

require 'optparse'
require 'tco'

def display_palette
  # TODO: Might be worth sorting, so the pallete is easier to navigate
  colours = Tco::get_available_colours
  colours_per_line = (`tput cols`.to_i / 9 - 0.5).ceil

  c = 0
  while c < colours.length do
    if (c + colours_per_line) < colours.length
      squares = colours_per_line
    else
      squares = colours.length - c
    end

    # Prepare the squares for the line
    square_styles = []
    squares.times do
      black = Tco::Colour.new([0,0,0])
      white = Tco::Colour.new([255,255,255])

      font_colour = if (colours[c] - black).abs > (colours[c] - white).abs
                      black
                    else
                      white
                    end

      square_styles.push [c, font_colour, colours[c]]
      c += 1
    end

    # The first empty line
    square_styles.each { |c, fg, bg| print Tco::colour " "*9, fg, bg }
    puts

    # Colour index
    square_styles.each do |c, fg, bg|
      print Tco::colour c.to_s.center(9), fg, bg
    end
    puts

    # Colour value
    square_styles.each do |c, fg, bg|
      print Tco::colour bg.to_s.center(9), fg, bg
    end
    puts

    # Final empty line
    square_styles.each { |c, fg, bg| print Tco::colour " "*9, fg, bg }
    puts
  end
end

options = {:newline => true}
parser = OptionParser.new do |opts|
  opts.banner = "Usage: tco [options] [TEXT]"

  opts.on("-f COLOUR", "--foreground COLOUR", "Foreground colour") do |fg|
    options[:fg] = fg
  end

  opts.on("-b COLOUR", "--background COLOUR", "Background colour") do |bg|
    options[:bg] = bg
  end

  opts.on("-l", "--light", "Use bright/bold font") do |intense|
    options[:bright] = intense
  end

  opts.on("-u", "--underline", "Underlined text") do |underline|
    options[:underline] = underline
  end

  opts.on("-s STYLE", "--style STYLE",
          "Decorate with a preset style") do |style|
    options[:style] = style
  end

  opts.on("-n", "--no-newline",
          "Don't append \\n to the end of the string") do |newline|
    options[:newline] = false
  end

  opts.on("-d", "--display-palette",
          "Show the current colour pallete") do |display|
    options[:display] = true
  end

  opts.on("-P PALETTE", "--force-palette PALETTE",
          "Show the current colour pallete") do |palette|
    options[:palette] = palette
  end

  opts.on("-p", "--parse",
          "Enable the c/fg/bg/text/us and",
          "s/style/text/ syntax") do |matching|
    options[:parse] = matching
  end

  opts.on("-r", "--raw-output", "Print the output escaped") do |raw|
    options[:raw] = raw
  end

  opts.on("-w", "--web", "Output HTML") do |html|
    options[:html] = html
  end
end

begin
  parser.parse!

  # Force palette setting
  Tco::use_palette options[:palette] if options.has_key? :palette

  if options.has_key? :display
    display_palette
    Kernel.exit! 0
  end

  if options.has_key? :style
    style = Tco::get_style name
  else
    style = Tco::Style.new
  end

  if options.has_key? :fg
    style.fg = options[:fg]
  end

  if options.has_key? :bg
    style.bg = options[:bg]
  end

  if options.has_key? :bright
    style.bright = options[:bright]
  end

  if options.has_key? :underline
    style.underline = options[:underline]
  end

  if ARGV.length > 0
    input = ARGV[0].gsub /\\[nt]/, "\\n" => "\n", "\\t" => "\t"
    print Tco::decorate input, style
    print "\n" unless !options[:newline]
  else
    while input = gets
      input.gsub! /\\[nt]/, "\\n" => "\n", "\\t" => "\t"
      print Tco::decorate input.chomp, style
      print "\n" if input =~ /\n$/
    end
  end

rescue Exception => e
  puts e
  exit
end
